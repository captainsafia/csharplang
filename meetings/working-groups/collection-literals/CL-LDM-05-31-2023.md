# C# LDM Collection Literals Agenda

## Core set of features for C# 12

1. We are not discussing any 'natural typing' scenarios today.  We're continuing to make progress in that space and would like to have a dedicated meeting on that topic.
2. This is the set of features we believe has a very intuitive and solid design around them, and would hit a good 'sweet spot' of capabilities and user satisfaction for the initial release.

### Target-typing to core collections and collections with classic collection initializers

https://github.com/dotnet/csharplang/blob/main/proposals/collection-literals.md#constructible-collection-types-target-types

Open Questions:
1. Does LDM agree with the priority order and totality of the support constructible collection types?
2. What is the behavior when users attempt to initialize an IEnumerable (or any interface type)? Do you get a List<T> or an undefined type?


### Target-typing with BCL attribute Create method

```cs
[CollectionLiteralBuilder(
    typeof(CollectionsMarshal),
    nameof(CollectionsMarshal.Create))]
public class MyCollection<T> : IEnumerable<T> { }
public static class CollectionsMarshal
{
    public static void Create<T>(
        int capacity,
        out ImmutableArray<T> collection,
        out Span<T> storage);
    
    public static void Create<T>(
        out ImmutableHashSet<T> collection,
        ReadOnlySpan<T> storage);
    
    public static void Create<TKey, TValue>(
        out ImmutableDictionary<TKey, TValue> collection,
        ReadOnlySpan<KeyValuePair<TKey, TValue>> storage);
}
```

Open Questions:
1. Does LDM agree with introducing a new pattern for collection construction?
1. If this API can't come in time, is it OK for the compiler to temporarily special case List<T> (and potentially ImmutableArray)?  

### Dictionaries
    
Created as a natural syntactic extension on collection literals:
    
```c#
List<int> list = [1, 2, 3];
Dictionary<string, int> nameToAge = ["Dustin": 42, "Cyrus": 43];
```
    
Syntax picked for two reasons:
1. Very brief.  A core goal of this feature is to prevent excessive syntax for simple ideas.
2. Very famliar to many languages that use colon here (JS, Python, Swift, Dart, Go, etc.).  Want to put best foot forward.
    
Downsides:
3. Does introduce syntactic ambiguity
    
```csharp
Dictionary<K, V> d = [a ? [b] : c]; // [a ? ([b]) : c)] or [(a ? [b]) : c]?
```
WG feeling is that this ambiguity though would be extremely rare to hit.  Picking 'expression' here (not k:v) seems totally fine.  If you do want K:V, parenthesize the key.
    
`Spreading` is also supported for dictionaries, allowing for nice things like:
    
```c#
Dictionary<string, int> nameToAge = ["Dustin": 42, "Cyrus": 43];
Dictionary<string, int> newBameToAge = [.. nameToAge, "Mads": 25];
```
    
Dictionaries (without 'Construct' methods) are rewritten as:   

```cs
Dictionary<string, int> nameToAge = ["Dustin": 42, "Cyrus": 43]; // rewritten as:

Dictionary<string, int> nameToAge = new Dictionary<string, int>(capacity: 2);
nameToAge["Dustin"] = 42;
nameToAge["Cyrus"] = 43;
    
// But it could have been (throw vs update semantics):
nameToAge.Add("Dustin", 42);
nameToAge.Add("Cyrus", 43);
```
    
Open Questions:
1. Does LDM agree with supporting dictionary literals for C#12?
2. How do we recognize dictionary types (IDictionary, Dictionary<K,V>, etc)?  When using interfaces, do we guarantee a particular concrete type?
3. What kind of behavior does dictionary creation (update or add semantics for duplicates)?
4. Is it feasible to have `k:v` expression inside a non-dictionary collection literal?  e.g.:
    
```c#
List<KeyValuePair<string, int>> pairs = ["Dustin": 42, "Cyrus": 43]; // Is this ok?  Or would we require you say:
    
List<KeyValuePair<string, int>> pairs = [new("Dustin", 42), new("Cyrus", 43)];
```
    
5. Use `expression_element` and `spread_element` in dictionary?  This requires effectively that constructing dictionaries understands how to incorporate a KVP *value* from an external source.  For example:
    
```c#
KeyValuePair<string, int> GetMads() => new("Mads", 24);
    
Dictionary<string, int> nameToAge = ["Dustin": 42, "Cyrus": 43, GetMads()]; // otherwise, you'd have to write:
    
var mads = GetMads();
Dictionary<string, int> nameToAge = ["Dustin": 42, "Cyrus": 43, mads.Key: mads.Value]; 
```
    
Note: supporting spreads for dictionaries strongly implies that this should "just work".  But we want LDM to be ok here.
    
6. Syntax ambiguity (shown above)

### Spreads

1. Should we use AddRange if available? (What if it boxes?)
2. Should we foreach the spreaded expr instead?
3. Syntax ambiguity:

```csharp
Range[] ranges = [range1, ..e, range2]; // ..e: spread or range?
```
