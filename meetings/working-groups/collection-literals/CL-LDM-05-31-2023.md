# C# LDM Collection Literals Agenda

## Core set of features for C# 12

### Target-typing to core collections and collections with classic collection initializers

https://github.com/dotnet/csharplang/blob/main/proposals/collection-literals.md#constructible-collection-types-target-types

Open Questions:
1. Does LDM agree with the priority order and totality of the support constructible collection types?
2. What is the behavior when users attempt to initialize an IEnumerable (or any interface type)? Do you get a List<T> or an undefined type?


### Target-typing with BCL attribute Create method

```cs
[CollectionLiteralBuilder(
    typeof(CollectionsMarshal),
    nameof(CollectionsMarshal.Create))]
public class MyCollection<T> : IEnumerable<T> { }
public static class CollectionsMarshal
{
    public static void Create<T>(
        int capacity,
        out ImmutableArray<T> collection,
        out Span<T> storage);
    
    public static void Create<T>(
        out ImmutableHashSet<T> collection,
        ReadOnlySpan<T> storage);
    
    public static void Create<TKey, TValue>(
        out ImmutableDictionary<TKey, TValue> collection,
        ReadOnlySpan<KeyValuePair<TKey, TValue>> storage);
}
```

Open Questions:
1. Does LDM agree with introducing a new pattern for collection construction?
1. If this API can't come in time, is it OK for the compiler to temporarily special case List<T> (and potentially ImmutableArray)?  

### Dictionaries

```cs
// Code samples for overview here?

// IDictionary<K, V> d = [e1, k1: v1, ..s1];

T __result = new T(capacity: __len);

__result[__e1.Key] = __e1.Value;
__result[__k1] = __v1;
foreach (var __t in __s1)
    __result[__t.Key] = __t.Value;

// further additions of the remaining elements
```

Open Questions:
1. Does LDM agree with supporting dictionary literals for C#12?
2. How do we recognize dictionary types (IDictionary, Dictionary<K,V>, etc)? 
3. What kind of behavior does dictionary creation (update or add semantics for duplicates)?
4. Is it feasible to have `k:v` expression inside a non-dictionary collection literal?
5. Use `expression_element` and `spread_element` in dictionary?
6. Syntax ambiguity:

```csharp
Dictionary<K, V> d = [a ? [b] : c]; // [a ? ([b]) : c)] or [(a ? [b]) : c]?
```

### Spreads

Corresponding 'construction' form of the 'slice' pattern. 
    
```C#
if (x is [var start, .. var middle, var end]) // pattern form:
    
List<string> values = ["start", .. middle, "end"]; // translates to potentially:
    
List<string> values = new List<string>(capacityIfKnown);
values.Add("start");
values.AddRange(middle);
values.Add("end");
    
// or potentially:
    
List<string> values = new List<string>(capacityIfKnown);
values.Add(start);
foreach (var v in middle)
    values.Add(v);
values.Add(end);
```
    
Should we use AddRange if available? What if it boxes? We could leave it underspecified and utilized compiler heuristics. Fits into the overal discussion of the presumption that "construction" semantics are well-behaved (like pattern matching semantics). 
    
Pros:
This will commonly be quite fast for many collections passed to AddRange.  AddRange often uses TryGetNonEnumeratedCount and CopyTo to update internal capacity, and then write directly into it.
    
Cons:
There are definitely cases where this will allocate more than direct foreach (for example, if the AddRange impl cannot use CopyTo, and must instead create a heap allocated IEnumerator).
This will box in the case where 'middle' is a struct.  We could detect that and `foreach` in that case.
    
