[# C# LDM Collection Literals Agenda

## Core set of features for C# 12

### Target-typing to core collections and collections with classic collection initializers

https://github.com/dotnet/csharplang/blob/main/proposals/collection-literals.md#constructible-collection-types-target-types

Open Questions:
1. Does LDM agree with the priority order and totality of the support constructible collection types?
2. What is the behavior when users attempt to initialize an IEnumerable (or any interface type)? Do you get a List<T> or an undefined type?


### Target-typing with BCL attribute Create method

```cs
[CollectionLiteralBuilder(
    typeof(CollectionsMarshal),
    nameof(CollectionsMarshal.Create))]
public class MyCollection<T> : IEnumerable<T> { }
public static class CollectionsMarshal
{
    public static void Create<T>(
        int capacity,
        out ImmutableArray<T> collection,
        out Span<T> storage);
    
    public static void Create<T>(
        out ImmutableHashSet<T> collection,
        ReadOnlySpan<T> storage);
    
    public static void Create<TKey, TValue>(
        out ImmutableDictionary<TKey, TValue> collection,
        ReadOnlySpan<KeyValuePair<TKey, TValue>> storage);
}
```

Open Questions:
1. Does LDM agree with introducing a new pattern for collection construction?
1. If this API can't come in time, is it OK for the compiler to temporarily special case List<T> (and potentially ImmutableArray)?  

### Dictionaries

```cs
// Code samples for overview here?

// IDictionary<K, V> d = [e1, k1: v1, ..s1];

T __result = new T(capacity: __len);

__result[__e1.Key] = __e1.Value;
__result[__k1] = __v1;
foreach (var __t in __s1)
    __result[__t.Key] = __t.Value;

// further additions of the remaining elements
```

Open Questions:
1. Does LDM agree with supporting dictionary literals for C#12?
2. How do we recognize dictionary types (IDictionary, Dictionary<K,V>, etc)? 
3. What kind of behavior does dictionary creation (update or add semantics for duplicates)?
4. Is it feasible to have `k:v` expression inside a non-dictionary collection literal?
5. Use `expression_element` and `spread_element` in dictionary?
6. Syntax ambiguity:

```csharp
Dictionary<K, V> d = [a ? [b] : c]; // [a ? ([b]) : c)] or [(a ? [b]) : c]?
```

### Spreads

1. Should we use AddRange if available? (What if it boxes?)
2. Should we foreach the spreaded expr instead?
3. Syntax ambiguity:

```csharp
Range[] ranges = [range1, ..e, range2]; // ..e: spread or range?
```
](https://github.com/captainsafia/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-05-31-2023.md)
