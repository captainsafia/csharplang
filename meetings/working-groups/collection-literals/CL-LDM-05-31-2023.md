# C# LDM Collection Literals Agenda

## Core set of features for C# 12

### Target-typing to core collections and collections with classic collection initializers

https://github.com/dotnet/csharplang/blob/main/proposals/collection-literals.md#constructible-collection-types-target-types

Open Questions:
1. Does LDM agree with the priority order and totality of the support constructible collection types?
2. What is the behavior when users attempt to initialize an IEnumerable (or any interface type)? Do you get a List<T> or an undefined type?


### Target-typing with BCL attribute Create method

Main examples:
    
```c#
List<int> list = [1, 2, 3]; // equivalent to:
CollectionsMarshal.Create<int>(capacity: 3, out List<int> list, out Span<T> __storage);
__storage[0] = 1;
__storage[1] = 2;
__storage[2] = 3;
    
// Works identically for ImmutableArray<T>.

// However, some types cannot give you the storage to write sequentially into.  For those, the pattern is:
ImmutableDictionary<string, int> namesToAge = [ "Dustin": 42, "Cyrus": 43 ]; // equivalent to:
    
// Storage is initialized (ideally on stack when safe), and passed to type to type to own creating its internal structure
ReadOnlySpan<KeyValuePair<string, int>> storage = [ new("Dustin", 42), new("Cyrus", 43) ]; // could be heap or stack.
CollectionsMarshal.Create<string, int>(out ImmutableDictionary<string, int> namesToAge, storage);
```
    
The pattern is:
    
```cs
// Attribute placed on collection target type, stating where to find the factory method.
// Specifies the type where it is found, and the factory method name.  Up to BCL to include.
    
[CollectionLiteralBuilder(
    typeof(CollectionsMarshal),
    nameof(CollectionsMarshal.Create))]
public class MyCollection<T> : IEnumerable<T> { } // or

[CollectionLiteralBuilder(
    typeof(CollectionsMarshal),
    nameof(CollectionsMarshal.Create))] 
public class MyDictionary<TKey, TValue> : IEnumerable<KVP<TKey, TValue>> { }
    
// Factory method shape:
public static class CollectionsMarshal
{
    // For cases where the instance can share out its storage and as a sequential buffer for caller to place the values in.
    // Storage span is passed out for caller to populate with no overhead.
    public static void Create<T>(
        int capacity,
        out ImmutableArray<T> collection,
        out Span<T> storage);
    
    // For cases where the final instance has to manage non-sequentual structure.  Storage is passed in and copied over to
    // internal structure.
    public static void Create<T>(
        out ImmutableHashSet<T> collection,
        ReadOnlySpan<T> storage);
    
    // Example of the shape for things like dictionaries.
    public static void Create<TKey, TValue>(
        out ImmutableDictionary<TKey, TValue> collection,
        ReadOnlySpan<KeyValuePair<TKey, TValue>> storage);
}
```

Open Questions:
1. Does LDM agree with introducing a new pattern for collection construction?
1. If this API can't come in time, is it OK for the compiler to temporarily special case List<T> (and potentially ImmutableArray)?  

### Dictionaries

```cs
// Code samples for overview here?

// IDictionary<K, V> d = [e1, k1: v1, ..s1];

T __result = new T(capacity: __len);

__result[__e1.Key] = __e1.Value;
__result[__k1] = __v1;
foreach (var __t in __s1)
    __result[__t.Key] = __t.Value;

// further additions of the remaining elements
```

Open Questions:
1. Does LDM agree with supporting dictionary literals for C#12?
2. How do we recognize dictionary types (IDiction ary, Dictionary<K,V>, etc)? 
3. What kind of behavior does dictionary creation (update or add semantics for duplicates)?
4. Is it feasible to have `k:v` expression inside a non-dictionary collection literal?
5. Use `expression_element` and `spread_element` in dictionary?
6. Syntax ambiguity:

```csharp
Dictionary<K, V> d = [a ? [b] : c]; // [a ? ([b]) : c)] or [(a ? [b]) : c]?
```

### Spreads

1. Should we use AddRange if available? (What if it boxes?)
2. Should we foreach the spreaded expr instead?
3. Syntax ambiguity:

```csharp
Range[] ranges = [range1, ..e, range2]; // ..e: spread or range?
```
