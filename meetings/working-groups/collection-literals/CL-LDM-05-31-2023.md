[# C# LDM Collection Literals Agenda

## Core set of features for C# 12

### Target-typing to core collections and collections with classic collection initializers

The following are constructible collection types that can be used to construct collection literals. These are the valid target types for collection literals.

The list is in priority order. If a collection type belongs in multiple categories, the first is used.


1. Single dimensional arrays (e.g. T[])

```c#
int[] a = [1, 2, 3]; // equivalent to:
int[] a = new int[] { 1, 2, 3 };
```

2. Span types (`Span<T>` and `ReadOnlySpan<T>`)

```c#
Span<int> a = [1, 2, 3]; // equivalent to either:

Span<int> a = new int[] { 1, 2, 3 }; // or
Span<int> a = stackalloc int[] { 1, 2, 3 };
```

Which one is picked depends on compiler heuristics around stack space (and is part of the 'params span' WG outcomes), and the ref-safety rules around 'a'.

Types with a suitable Construct method.  This will be discussed below, but related heavily to immutable collections, and how to efficiently construct them.
Types that implement System.Collections.IDictionary - dictionary collection initializers
Interface types I<TKey, TValue> implemented by System.Collections.Generic.Dictionary<TKey, TValue> (e.g. IDictionary<TKey, TValue>, IReadOnlyDictionary<TKey, TValue>)
Types that implement System.Collections.IEnumerable - collection initializers
Interface types I<T> implemented by System.Collections.Generic.List<T> (e.g. IEnumerable<T>, IList<T>, IReadOnlyList<T>)


https://github.com/dotnet/csharplang/blob/main/proposals/collection-literals.md#constructible-collection-types-target-types

Open Questions:
1. Does LDM agree with the priority order and totality of the support constructible collection types?
2. What is the behavior when users attempt to initialize an IEnumerable (or any interface type)? Do you get a List<T> or an undefined type?


### Target-typing with BCL attribute Create method

```cs
[CollectionLiteralBuilder(
    typeof(CollectionsMarshal),
    nameof(CollectionsMarshal.Create))]
public class MyCollection<T> : IEnumerable<T> { }
public static class CollectionsMarshal
{
    public static void Create<T>(
        int capacity,
        out ImmutableArray<T> collection,
        out Span<T> storage);
    
    public static void Create<T>(
        out ImmutableHashSet<T> collection,
        ReadOnlySpan<T> storage);
    
    public static void Create<TKey, TValue>(
        out ImmutableDictionary<TKey, TValue> collection,
        ReadOnlySpan<KeyValuePair<TKey, TValue>> storage);
}
```

Open Questions:
1. Does LDM agree with introducing a new pattern for collection construction?
1. If this API can't come in time, is it OK for the compiler to temporarily special case List<T> (and potentially ImmutableArray)?  

### Dictionaries

```cs
// Code samples for overview here?

// IDictionary<K, V> d = [e1, k1: v1, ..s1];

T __result = new T(capacity: __len);

__result[__e1.Key] = __e1.Value;
__result[__k1] = __v1;
foreach (var __t in __s1)
    __result[__t.Key] = __t.Value;

// further additions of the remaining elements
```

Open Questions:
1. Does LDM agree with supporting dictionary literals for C#12?
2. How do we recognize dictionary types (IDictionary, Dictionary<K,V>, etc)? 
3. What kind of behavior does dictionary creation (update or add semantics for duplicates)?
4. Is it feasible to have `k:v` expression inside a non-dictionary collection literal?
5. Use `expression_element` and `spread_element` in dictionary?
6. Syntax ambiguity:

```csharp
Dictionary<K, V> d = [a ? [b] : c]; // [a ? ([b]) : c)] or [(a ? [b]) : c]?
```

### Spreads

1. Should we use AddRange if available? (What if it boxes?)
2. Should we foreach the spreaded expr instead?
3. Syntax ambiguity:

```csharp
Range[] ranges = [range1, ..e, range2]; // ..e: spread or range?
```
](https://github.com/captainsafia/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-05-31-2023.md)
